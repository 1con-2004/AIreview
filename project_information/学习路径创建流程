# 学习路径创建流程

## 整体分析

### 功能概述
学习路径模块将在个人中心页面的个人信息区域和统计图表区域之间添加，主要功能是基于学生的学习数据，利用AI大模型分析，提供个性化的学习建议和题目推荐。该模块分为三个核心板块：

1. **弱点分析板块**：展示用户在哪些标签的题目通过率低，介绍这些标签算法的核心思路
2. **学习方向板块**：为用户定制个性化学习路径，推荐学习方向并提供相关学习资源的网络链接
3. **题目推荐板块**：从现有题库中推荐适合用户的题目，并设计"导航路线"式UI展示学习进度

### 技术架构
- **前端**：Vue 3组件，使用Element Plus UI组件库，结合ECharts实现可视化
- **后端**：Node.js + Express API接口，MySQL数据库存储
- **AI大模型**：利用已有的zhipuAI.js接口调用智谱AI服务

### 数据流向
```mermaid
graph TD
    A[用户访问个人中心] --> B[前端请求后端API]
    B --> C[后端聚合用户数据]
    C --> D[调用智谱AI接口分析]
    D --> E[格式化AI返回结果]
    E --> F[返回给前端展示]
    F --> G[前端渲染学习路径UI]
```

## 后端实现

### 数据库调整
需要创建以下数据库表：
1. **user_learning_path**：存储用户个性化学习路径
```sql
CREATE TABLE user_learning_path (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  path_name VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

2. **user_weak_tags**：存储用户薄弱的标签和推荐资源
```sql
CREATE TABLE user_weak_tags (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  path_id INT NOT NULL,
  tag_name VARCHAR(100) NOT NULL,
  description TEXT,
  core_concept TEXT,
  pass_rate DECIMAL(5,2),
  resource_links JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (path_id) REFERENCES user_learning_path(id)
);
```

3. **user_recommended_problems**：存储为用户推荐的题目
```sql
CREATE TABLE user_recommended_problems (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  path_id INT NOT NULL,
  problem_id INT NOT NULL,
  order_index INT NOT NULL,
  reason TEXT,
  is_completed BOOLEAN DEFAULT FALSE,
  completed_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (path_id) REFERENCES user_learning_path(id),
  FOREIGN KEY (problem_id) REFERENCES problems(id)
);
```

### API接口设计
```mermaid
sequenceDiagram
    participant 前端
    participant 后端API
    participant 数据库
    participant 智谱AI
    前端->>后端API: 请求生成学习路径
    后端API->>数据库: 查询用户提交记录和题目信息
    数据库-->>后端API: 返回用户数据
    后端API->>后端API: 数据预处理和统计
    后端API->>智谱AI: 发送提示词请求分析
    智谱AI-->>后端API: 返回分析结果
    后端API->>后端API: 结果格式化和处理
    后端API->>数据库: 存储分析结果和推荐
    后端API-->>前端: 返回学习路径数据
```

#### 需要实现的API端点：
1. `/api/learning-path/analyze-weak-points`：分析用户薄弱点
2. `/api/learning-path/recommend-directions`：推荐学习方向和资源
3. `/api/learning-path/recommend-problems`：推荐适合的题目
4. `/api/learning-path/get-complete-path`：获取完整学习路径

### 业务逻辑流程
```mermaid
flowchart TB
    A[开始] --> B{检查缓存是否存在有效学习路径}
    B -->|是| C[返回缓存学习路径]
    B -->|否| D[收集用户提交数据]
    D --> E[按标签统计通过率]
    E --> F[识别薄弱标签]
    F --> G[准备AI提示词]
    G --> H[调用zhipuAI.js接口]
    H --> I[解析AI返回结果]
    I --> J[查找相关学习资源]
    J --> K[筛选推荐题目]
    K --> L[生成完整学习路径]
    L --> M[缓存学习路径]
    M --> N[返回学习路径数据]
    N --> O[结束]
```

### 代码实现要点
1. **数据聚合**：聚合用户提交记录、题目信息、知识点掌握情况等数据
2. **标签分析**：计算用户在不同标签题目的通过率，识别薄弱点
3. **AI提示词生成**：根据用户数据构建有效的提示词，引导AI给出准确分析
4. **网络资源获取**：通过AI接口获取学习资源链接
5. **推荐算法**：基于用户薄弱点和已完成题目，推荐合适的下一步题目

### 示例实现代码

#### 1. 生成学习路径API代码
```javascript
// 生成完整学习路径
router.post('/generate-path', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    console.log('开始生成学习路径，用户ID:', userId);
    
    // 检查是否已有最近生成的学习路径（缓存策略）
    const [existingPath] = await db.query(`
      SELECT * FROM user_learning_path
      WHERE user_id = ? AND created_at > DATE_SUB(NOW(), INTERVAL 3 DAY)
      ORDER BY created_at DESC LIMIT 1
    `, [userId]);
    
    if (existingPath && existingPath.length > 0) {
      console.log('找到最近生成的学习路径，返回现有数据');
      // 获取完整学习路径数据
      const pathData = await getCompleteLearningPath(existingPath[0].id, userId);
      return res.json({
        success: true,
        message: '返回已有学习路径',
        data: pathData
      });
    }
    
    // 聚合用户提交数据
    const userData = await aggregateUserData(userId);
    
    // 计算标签通过率
    const tagPassRates = calculateTagPassRates(userData.submissions);
    
    // 识别薄弱标签（通过率低于60%）
    const weakTags = tagPassRates
      .filter(tag => tag.passRate < 60)
      .sort((a, b) => a.passRate - b.passRate)
      .slice(0, 5);
    
    // 准备AI提示词
    const prompt = generateAIPrompt(userData, weakTags);
    
    // 调用智谱AI
    const aiInstance = new ZhipuAI();
    const aiResponse = await aiInstance.chat([{
      role: "user",
      content: prompt
    }]);
    
    // 解析AI返回结果
    const analysisResult = parseAIResponse(aiResponse);
    
    // 开始事务
    await db.query('START TRANSACTION');
    
    try {
      // 创建学习路径记录
      const [pathResult] = await db.query(`
        INSERT INTO user_learning_path (user_id, path_name, description)
        VALUES (?, ?, ?)
      `, [userId, '个性化学习路径', analysisResult.description]);
      
      const pathId = pathResult.insertId;
      
      // 存储薄弱标签和学习资源
      for (const tag of analysisResult.weakPoints) {
        await db.query(`
          INSERT INTO user_weak_tags 
          (user_id, path_id, tag_name, description, core_concept, pass_rate, resource_links)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `, [
          userId, 
          pathId,
          tag.name,
          tag.description,
          tag.coreConcept,
          tag.passRate,
          JSON.stringify(tag.resources)
        ]);
      }
      
      // 存储推荐题目
      for (let i = 0; i < analysisResult.recommendedProblems.length; i++) {
        const problem = analysisResult.recommendedProblems[i];
        await db.query(`
          INSERT INTO user_recommended_problems
          (user_id, path_id, problem_id, order_index, reason)
          VALUES (?, ?, ?, ?, ?)
        `, [
          userId,
          pathId,
          problem.id,
          i + 1,
          problem.reason
        ]);
      }
      
      // 提交事务
      await db.query('COMMIT');
      
      // 获取完整学习路径数据
      const pathData = await getCompleteLearningPath(pathId, userId);
      
      res.json({
        success: true,
        message: '学习路径生成成功',
        data: pathData
      });
      
    } catch (error) {
      // 回滚事务
      await db.query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('生成学习路径失败:', error);
    res.status(500).json({
      success: false,
      message: '生成学习路径失败: ' + error.message
    });
  }
});
```

#### 2. 获取完整学习路径数据辅助函数
```javascript
// 获取完整学习路径数据
async function getCompleteLearningPath(pathId, userId) {
  // 获取路径基本信息
  const [pathInfo] = await db.query(`
    SELECT * FROM user_learning_path WHERE id = ?
  `, [pathId]);
  
  if (!pathInfo || pathInfo.length === 0) {
    throw new Error('学习路径不存在');
  }
  
  // 获取薄弱标签和资源
  const [weakTags] = await db.query(`
    SELECT * FROM user_weak_tags 
    WHERE path_id = ? AND user_id = ?
    ORDER BY pass_rate ASC
  `, [pathId, userId]);
  
  // 获取推荐题目
  const [recommendedProblems] = await db.query(`
    SELECT rp.*, p.title, p.difficulty, p.tags
    FROM user_recommended_problems rp
    JOIN problems p ON rp.problem_id = p.id
    WHERE rp.path_id = ? AND rp.user_id = ?
    ORDER BY rp.order_index
  `, [pathId, userId]);
  
  // 构建完整路径数据
  return {
    pathInfo: pathInfo[0],
    weakTags: weakTags.map(tag => ({
      ...tag,
      resource_links: JSON.parse(tag.resource_links || '[]')
    })),
    recommendedProblems: recommendedProblems
  };
}
```

#### 3. 用户数据聚合函数
```javascript
// 聚合用户数据
async function aggregateUserData(userId) {
  // 获取用户提交记录
  const [submissions] = await db.query(`
    SELECT s.*, p.title, p.difficulty, p.tags
    FROM submissions s
    JOIN problems p ON s.problem_id = p.id
    WHERE s.user_id = ?
    ORDER BY s.created_at DESC
  `, [userId]);
  
  // 获取用户信息
  const [userInfo] = await db.query(`
    SELECT u.*, up.expertise_level, up.learning_goal
    FROM users u
    LEFT JOIN user_profile up ON u.id = up.user_id
    WHERE u.id = ?
  `, [userId]);
  
  // 获取标签信息
  const allTags = new Set();
  submissions.forEach(sub => {
    try {
      const tags = JSON.parse(sub.tags || '[]');
      tags.forEach(tag => allTags.add(tag));
    } catch (e) {
      console.error('解析标签失败:', e);
    }
  });
  
  return {
    userInfo: userInfo[0] || {},
    submissions,
    tags: Array.from(allTags)
  };
}
```

#### 4. 标签通过率计算函数
```javascript
// 计算标签通过率
function calculateTagPassRates(submissions) {
  const tagStats = {};
  
  // 统计每个标签的尝试次数和通过次数
  submissions.forEach(sub => {
    try {
      const tags = JSON.parse(sub.tags || '[]');
      tags.forEach(tag => {
        if (!tagStats[tag]) {
          tagStats[tag] = { attempts: 0, accepted: 0 };
        }
        
        tagStats[tag].attempts++;
        if (sub.status === 'Accepted') {
          tagStats[tag].accepted++;
        }
      });
    } catch (e) {
      console.error('解析标签失败:', e);
    }
  });
  
  // 计算通过率
  return Object.entries(tagStats).map(([tag, stats]) => ({
    tag,
    attempts: stats.attempts,
    accepted: stats.accepted,
    passRate: Math.round((stats.accepted / stats.attempts) * 100)
  }))
  .filter(item => item.attempts >= 3) // 只考虑尝试次数大于等于3的标签
  .sort((a, b) => a.passRate - b.passRate); // 按通过率升序排序
}
```

#### 5. AI提示词生成函数
```javascript
// 生成AI提示词
function generateAIPrompt(userData, weakTags) {
  const weakTagNames = weakTags.map(t => t.tag).join(', ');
  
  return `请根据以下用户信息分析其算法学习情况并生成个性化学习路径：

用户基本信息：
- 尝试过的题目总数：${userData.submissions.length}
- 通过的题目数：${userData.submissions.filter(s => s.status === 'Accepted').length}
- 薄弱的标签：${weakTagNames}

我需要你完成以下三个任务：

1. 分析以上薄弱标签对应的算法核心思路：对于每个标签，简要介绍该算法的核心思路、常见题型和解题方法（每个标签200字以内）。

2. 推荐学习路径与资源：根据用户的薄弱标签，为用户推荐2-3个学习方向。对于每个学习方向，提供1-2个高质量的学习资源，包括资源标题、URL链接和简短描述。要求资源必须是真实存在的、具体的博客文章或教程链接，偏好CSDN、知乎、LeetCode等平台上的中文资源。

3. 题目推荐：从ID范围1-100的题目中，根据用户薄弱点推荐5-8道适合的练习题，要按照由易到难的顺序排列，并解释每道题的推荐理由。

请按以下JSON格式回复：
{
  "description": "整体学习路径描述",
  "weakPoints": [
    {
      "name": "标签名",
      "description": "该标签的问题描述",
      "coreConcept": "算法核心思路介绍",
      "passRate": 通过率数字,
      "resources": [
        {
          "title": "资源标题",
          "url": "资源URL",
          "description": "资源简述"
        }
      ]
    }
  ],
  "recommendedProblems": [
    {
      "id": 题目ID,
      "reason": "推荐理由"
    }
  ]
}`;
}
```

#### 6. AI响应解析函数
```javascript
// 解析AI响应
function parseAIResponse(aiResponse) {
  try {
    // 清理响应文本中的markdown等格式
    const cleanResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    const result = JSON.parse(cleanResponse);
    
    // 验证返回的对象结构
    if (!result.weakPoints || !result.recommendedProblems) {
      throw new Error('AI返回的数据格式不正确');
    }
    
    return result;
  } catch (error) {
    console.error('解析AI响应失败:', error);
    throw new Error('解析AI响应失败: ' + error.message);
  }
}
```

## 前端实现

### 组件结构
```mermaid
graph TD
    A[LearningPathContainer] --> B[WeakPointsAnalysis]
    A --> C[LearningDirections]
    A --> D[RecommendedProblems]
    B --> B1[标签通过率图表]
    B --> B2[算法核心思路说明]
    C --> C1[学习方向列表]
    C --> C2[外部资源链接]
    D --> D1[进度指示器]
    D --> D2[推荐题目卡片]
```

### UI设计要点
1. **整体风格**：简洁现代，与个人中心其他部分保持一致
2. **弱点分析区域**：使用雷达图展示不同标签的掌握程度
3. **学习方向区域**：卡片式布局，每个方向包含描述和资源链接
4. **题目推荐区域**：
   - 阶梯式进度指示器，直观展示学习路径
   - 题目卡片包含难度、标签、推荐理由等信息
   - 与已完成题目有明确的视觉区分

### 交互设计
1. **定期刷新**：允许用户手动刷新学习路径
2. **题目跳转**：点击推荐题目可直接跳转到题目页面
3. **资源预览**：外部资源链接可预览内容摘要
4. **进度追踪**：完成推荐题目后自动更新进度指示

## 实现流程步骤

[ ] 1. 设计并创建数据库表结构
[ ] 2. 实现后端数据聚合和统计功能
[ ] 3. 开发zhipuAI提示词生成和解析功能
[ ] 4. 实现学习资源搜索和筛选API
[ ] 5. 开发题目推荐算法
[ ] 6. 创建前端学习路径容器组件
[ ] 7. 实现弱点分析组件及图表
[ ] 8. 开发学习方向和资源展示组件
[ ] 9. 设计并实现题目推荐的导航式UI
[ ] 10. 完成前后端数据交互
[ ] 11. 测试学习路径生成和展示功能
[ ] 12. 优化响应速度和用户体验 